# Scaling


## Notation

In this chapter we will use summation notation. If you are not familiar with summation notation, we present a brief overview here.

Consider a scenario where we have the IQ data for three participants We use the N symbol to represent the number of participants. Because we have three participants N = 3. The data for these participants is illustrated in Figure \@ref(fig:notationdata).

Notice how each person in the data set can be represented by the variable X: the first person by $X_1$, the second by $X_2$, and the third by $X_3$. Often we refer to individuals in a data set by using the variable X accompanied by a subscript (e.g., 1, 2, 3, etc.).

```{r notationdata, echo = FALSE, out.width="40%", fig.cap = "Data for understanding summation notation"}
knitr::include_graphics("ch_scaling/images/screenshot_data_n6.png")
```

Referring to participants using the variable X and subscript is valuable because it can be used in conjunction with the sigma (i.e., $\Sigma$) symbol for summation. Consider the example below in which we use the summation notation to indicate that we want to add all the X values (representing IQ) for the participants. We use a lower case $i$ to represent all possible subscript values. The notation, $i$ = 1, below the $\Sigma$ symbol indicates that we should start with participant 1. The notation, N, above the $\Sigma$ symbol indicates that we should iterate $i$ up to the value indicated by N; in this case 3, because there are three participants.

$$
\begin{aligned} 
\sum_{i=1}^{N} X_i &=  X_1 + X_2 + X_3\\ 
&= 110 + 120 + 100 \\
&= 330
\end{aligned} 
$$

Sometimes, to simplify the notation, the numbers above and below the $\Sigma$ symbol are omitted. Likewise, the $i$ subscript is omitted. There is a general understanding that when these components of the notation are omitted the version of the notation above is implied.

$$
\begin{aligned} 
\sum{X} &= X_1 + X_2 + X_3\\ 
&= 110 + 120 + 100\\
&= 330
\end{aligned} 
$$


**Calculating a mean**. The full version of the notation can be used to indicate how an average/mean is calculated.


$$
\begin{aligned} 
\bar{X} &= \frac{\sum_{i=1}^{N} X_i}{N} \\
&= \frac{X_1 + X_2 + X_3}{3}\\ 
&= \frac{110 + 120 + 100}{3}\\
&= \frac{330}{3}\\
&= 110\\
\end{aligned} 
$$

Likewise, the concise version of the notation can be used to indicate how an average/mean is calculated.

$$
\begin{aligned} 
\bar{X} &= \frac{\sum{X}}{N} \\
&= \frac{X_1 + X_2 + X_3}{3}\\ 
&= \frac{110 + 120 + 100}{3}\\
&= \frac{330}{3}\\
&= 110\\
\end{aligned} 
$$


**Calculating squared differences**.A common task in statistics is to calculate 1) the squared difference between each person and the mean, and 2) add up those squared differences. This calculation is easily expressed with the full version of the notation.

$$
\begin{aligned} 
\sum_{i=1}^{N}{(X_i - \bar{X})^2} &= (X_1-\bar{X})^2 + (X_2-\bar{X})^2 + (X_3-\bar{X})^2\\ 
&= (110-110)^2 + (120-110)^2 + (100-110)^2\\
&= (0)^2 + (10)^2 (-10)^2 \\
&= 0 + 100 + 100 \\
&= 200
\end{aligned} 
$$

Likewise, the sum of the squared differences from the mean can be expressed using the concise version of the notation.

$$
\begin{aligned} 
\sum{(X - \bar{X})^2} &= (X_1-\bar{X})^2 + (X_2-\bar{X})^2 + (X_3-\bar{X})^2\\ 
&= (110-110)^2 + (120-110)^2 + (100-110)^2\\
&= (0)^2 + (10)^2 (-10)^2 \\
&= 0 + 100 + 100 \\
&= 200
\end{aligned} 
$$

## Measurement Notation

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(sjstats) # say no if complied ...
height_data <- read_csv("data_heights.csv", na = c("", "-999"))

```

You may be familiar with the notation typically used when making inferences from a sample to a population. Unfortunately, the notation used in Psychological Measurement is different - similar but different. For the purposes of this course we use the notation and formulas below. Notice that we use N in the denominator - that is we use the population-level variance formula - even though we are working with sample data. Typically, measurement textbooks treat the sample as our population of interest. This difference is often a source of confusion for students.


$$
\begin{aligned}
\overline{X} &= \frac{\sum{X}}{N} \\
\end{aligned}
$$


$$
\begin{aligned}
S^2_X &= \frac{\sum{(X - \overline{X})^2}}{N} \\
\end{aligned}
$$


$$
\begin{aligned}
S_X &= \sqrt{\frac{\sum{(X - \overline{X})^2}}{N}} \\
\end{aligned}
$$



## Data entry

We begin by entering data into Excel (or any other spreadsheet) as per below. Notice how we use the first row as a header for the column names. Once we enter the data this way we need to save it as a .CSV file (comma separated values). You do so using the Save As menu item in Excel. Once the Save window appears - you will notice a File Format pull-down button. Use the button to select the CSV (comma delimited) option. Indicate a file name of "data_heights.csv" and save the file.

```{r, echo=FALSE, out.width="35%"}
knitr::include_graphics("ch_scaling/images/scaling_data_excel.png")
```


What is a .CSV file? It's just a text file where the columns are separated by commas. If you were to open the file in TextEdit on a Mac (or Notepad on Windows) you would see something like the image below. You don't need to do this step - but if you did, it would just show you how the file is saved on disk.

```{r, echo=FALSE, out.width="25%"}
knitr::include_graphics("ch_scaling/images/scaling_data_text.png")
```


## Loading data

Begin by creating a Project in RStudio on your computer (or via RStudio Cloud). Place the "data_heights.csv" in the Project folder. If you are using R Studio Cloud this means uploading the file via the Upload button the File tab (see picture below):

```{r, echo=FALSE, out.width="50%"}
knitr::include_graphics("ch_scaling/images/upload_button.png")
```


Prior to loading the data we have to install the tidyverse and sjstats packages. This only needs to be done once if you are using RStudio your computer. If you are using RStudio in the Cloud you need to do it once for each project/workspace. You install these packages by typing the command below in the CONSOLE. Do NOT put these commands in your script. It will take some time to run. Don't worry about all the text feedback you see on the screen.

```{r, eval = FALSE}
install.packages("tidyverse", dep = TRUE)
install.packages("sjstats", dep = TRUE)
```


From this point on place all the R commands into your script. We begin by activating the tidyverse and sjstats packages with the library() command. Then we load the data using read_csv(). Notice how use indicate missing values using the **na** argument of the read_csv() command; if the computer see nothing in the column or -999 it puts in a missing value place holder.

```{r, eval = TRUE}
library(tidyverse)
library(sjstats)

height_data <- read_csv("data_heights.csv", na = c("", "-999"))
```

We can see the columns in the data we loaded using the glimpse() command:

```{r}
glimpse(height_data)
```

The sex and part_id (participant identification number) columns are categorical variables. We need to let the R know this fact. We do so by converting them to "factor" columns with the command below.

```{r}
height_data <- height_data %>%
  mutate(part_id = as_factor(part_id),
         sex = as_factor(sex))

```

Using glimpse() again we see these columns have fct after them indicating that they are factors (i.e., categorical variables):

```{r}
glimpse(height_data)
```

## Viewing data

We can view all of the data we entered with the command below:

```{r}
height_data %>% as.data.frame()
```


## Summary statistics

To obtain the mean and standard deviation (population formula) for each column in the data set we use the commands below. These are fulling explained in the previous "Handling data with the tidyverse" chapter.

```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x)
)

height_data %>%
    summarise(across(.cols = where(is.numeric),
                     .fns = desired_descriptives,
                     na.rm = TRUE)) %>%
  as.data.frame()
```



## Converting units


### Inches

In the previous sections we have examined participant heights using centimeters (cm). We can, however, express participants heights using inches. It's a simple process to convert cm to inches - we simply divide by 2.54. If you examine the rule below you can see that 2.54 cm corresponds to 1 inch.

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("ch_scaling/images/ruler.png")
```

#### Hand calculation

We can express this conversion more formally with equations below. In this Equation we use $X_i$ to indicate the height (in cm) of the $i^{th}$ person in a set of N people.

$$
\begin{aligned}
\text{height in inches for the ith person} = \frac{X_i}{2.54}\\
\end{aligned}
$$


In the context of our data we can convert John's height of 190 cm to inches using this process:

$$
\begin{aligned}
\text{height in inches for the ith person} &= \frac{X_i}{2.54}\\
&= \frac{\text{John's height in cm}}{2.54}\\
&= \frac{190}{2.54}\\
&= 74.80315
\end{aligned}
$$


Thus, John is 190 cm tall or 74.8 inches tall. Of course, John's height has not changed because we are now expressing it in inches. All that has changed is the units we use to indicate his height.


#### R calculation

We can create a new column in our data set that has the height of everyone in inches using the code below:

```{r}

height_data <- height_data %>%
  mutate(inch_height = cm_height / 2.54)
```

We can see the new column (inches) with the code below.

```{r}
height_data %>% as.data.frame()
```

We can obtain the mean and standard deviation (population formula) for the cm and inches columns with the command below. Note that we added "%>% t()" in this version - this simply transposes the row to a column so the results don't go off the right side of your screen.

```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x)
)

height_data %>%
    summarise(across(.cols = where(is.numeric),
                     .fns = desired_descriptives,
                     na.rm = TRUE)) %>%
  as.data.frame() %>% t()
```


#### Summary

```{r, echo = FALSE}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x),
  N = ~sum(!is.na(.x))
)

row_sum <- height_data %>% 
  summarise(across(.cols = where(is.numeric),
                   .fns =  desired_descriptives,
                   .names = "{col}___{fn}"))

long_summary <- row_sum %>%
  pivot_longer(cols = everything(),
               names_to = c("unit", "stat"),
               names_sep = c("___"),
               values_to = "value")

summary_table <- long_summary %>% 
  pivot_wider(names_from = stat,
              values_from = value)

# round to 3 decimals
summary_table_rounded <- summary_table %>%
  mutate(across(.cols = where(is.numeric),
                .fns= round,
                digits = 3)) %>%
  as.data.frame()

kableExtra::kable(summary_table_rounded)
```


Examine the summary table above. By converting heights in cm to heights in inches we simply changed the units used to represent those heights. The conversion did not change anyone's actual height. Nor did this conversion change the height of one person relative to another person -- all we did was change the units used to represent the heights.

Both inches and centimeters are ratio-scale scale heights. The zero point on the measurement scale is meaningful and not arbitrary. Below we examine two approaches to representing heights (*z*-scores and T-scores) for which the zero-point depends on the nature of the data. This initially seems like an odd approach - but you will that there are many benefits to expressing scores/heights in this manner. 



### *z*-scores

One alternative approach to representing scores, or more specifically heights, is using *z*-scores. With *z*-scores each person's score (i.e., height) is represented relative to a frame of reference. More specifically, scores are represented relative to a particular mean and standard deviation. Often the frame of reference (i.e., mean and standard deviation) used to calculate *z*-scores is the mean and standard deviation of all the participants in a data set - though we will see later other frames of reference are possible.

The advantage of *z*-scores is that by simply looking a person's *z*-score we can tell if they are above or below the mean for the frame of reference. Specifically, when *z*-scores are positive this indicates that a person is above the mean for the frame of reference; likewise, when *z*-score are negative this indicates that the person is below the mean for the frame of reference. The magnitude of the *z*-score indicates how distant that person is from the mean of the frame of reference in standard deviation units. 

In we example our data we find that John has a height of 190 cm. We use the heights of the people in our data set as a frame of reference. Specifically, we calculate a mean height of 173.3 cm and a standard deviation (population formula) of 8.013114 cm. We use these values as a frame of reference when calculating John's *z*-score. Using this frame of reference John's height of 190 cm can be expressed as a *z*-score of 2.084084 (calculation below). Because this is a positive value we know John is taller than the average person in the frame of reference (i.e, the people in our data set). Likewise, the magnitude of the *z*-score, 2.084084, indicates that John is 2.084084 standard deviations taller than the average person in our frame of reference (i.e., the people in our data set). This means that John is quite tall - **relative** to the other people in our data set. The key word here is **relative** - *z*-scores provide information about a person's score relative to some frame of reference. In this example, the frame of reference was all of the people in the data set.


#### Hand calculation

Let's walk through converting John's height from cm to a *z*-score. The first step is determining the frame of reference we want to use to calculate the *z*-score. We decide to use the entire data set a frame of reference.

We find that the for the entire data set we have the mean and standard deviation (population formula) below that will serve as a frame of reference.

$$
\begin{aligned}
\overline{X} &= 173.3 \\
S_X &= 8.013114 \\
\end{aligned}
$$


To convert a person's original score to a *z*-score we use the formula below. Notice that the formula contains their original score (i.e., $X_i$) as well and the mean (i.e., $\overline{X}$) and standard deviation (i.e., $S_X$) of the frame of reference.

$$
\begin{aligned}
z_i = \frac{X_i - \overline{X}}{S_X}\\
\end{aligned}
$$


Here is the calculation for John:

$$
\begin{aligned}
z_i &= \frac{X_i - \overline{X}}{S_X}\\
&= \frac{\text{(John's height in cm)} - \overline{X}}{S_X}\\
&= \frac{190 - 173.3}{8.013114}\\
&= \frac{16.7}{8.013114}\\
&= 2.084084\\
\end{aligned}
$$


As noted previously: Because this is a positive value we know John is taller than the average person in the frame of reference (i.e, the people in our data set). Likewise, the magnitude of the *z*-score, 2.084084, indicates that John is 2.084084 standard deviations taller than the average person in our frame of reference (i.e., the people in our data set). This means that John is quite tall - **relative** to the other people in our data set. The key word here is **relative** - *z*-scores provide information about a person's score relative to some frame of reference. In this example, the frame of reference was all of the people in the data set.

#### R calculation

We can use R to calculate the *z*-score for everyone in our data set. Because we are using the data set itself as the frame of reference we can use to code to represent the mean and standard deviation for the data set - our frame of reference. Specifically,  where you see **mean(cm_height)** in the code below computer substitutes the mean of cm_height column (i.e., 173.3) - our frame of reference. Likewise, where you see **sd_pop(cm_height)** the computer substitutes the standard deviation of cm_height column (i.e., 8.013114) - our frame of reference. You can see the formula in the mutate command below is the same as the formula used above in the hand calculation - just expressed differently.

We could write the code below:

```{r, eval = FALSE}

height_data <- height_data %>%
  mutate(z_data = (  cm_height - 173.3  )  /  8.013114  )
```

But because the mean and standard deviation are based on all of our currernt data we can write it as below - this avoid making typos in the numbers:


```{r}

height_data <- height_data %>%
  mutate(z_data = (  cm_height - mean(cm_height)  )  /  sd_pop(cm_height)  )
```

Use the code below to see the data with the new column. 

```{r}
height_data %>% as.data.frame()
```

Notice that each person now has a *z*-score. Just by looking at the positive/negative sign for the *z*-score we can tell if a person is taller/shorter than the mean for the data set (our frame of reference).


#### Summary

We can obtain the mean for the cm, inches, and *z*-score columns with the command below:


```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x)
)

height_data %>%
    summarise(across(.cols = where(is.numeric),
                     .fns = desired_descriptives,
                     na.rm = TRUE)) %>%
  as.data.frame() %>% t()
```

This output may be confusing. Consider the cm_height_mean of 1.733e+02 the e+02 means move the decimal two places to the right. Likewise, consider the z_data_mean of -1.414e-15 the e-15 means move the decimal 15 places to the left.

We can see this information presented in table form below (decimals adjusted). You can see that *z*-scores are simply a way of representing heights with a different type of unit. By converting heights to *z*-scores we have not changed anyone's actual height. Nor have we changed the relative heights of any two individuals. We have only changed the units used to express those heights.

A special case: Also notice that when we use the data set itself as the frame of reference something interesting happens with *z*-scores. Specifically, the *z*-score column has a mean of zero and a standard deviation of 1.0. This won't always be the case. If we use a frame of reference other than our data set, the mean and standard deviation of *z*-scores in our data set will not necessarily be equal to 0 and 1, respectively.



```{r, echo = FALSE}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x),
  N = ~sum(!is.na(.x))
)

row_sum <- height_data %>% 
  summarise(across(.cols = where(is.numeric),
                   .fns =  desired_descriptives,
                   .names = "{col}___{fn}"))

long_summary <- row_sum %>%
  pivot_longer(cols = everything(),
               names_to = c("unit", "stat"),
               names_sep = c("___"),
               values_to = "value")

summary_table <- long_summary %>% 
  pivot_wider(names_from = stat,
              values_from = value)

# round to 3 decimals
summary_table_rounded <- summary_table %>%
  mutate(across(.cols = where(is.numeric),
                .fns= round,
                digits = 3)) %>%
  as.data.frame()

kableExtra::kable(summary_table_rounded)
```

### T-scores

T-scores are simply another unit for representing scores. Do not confuse the T-score with the *t*-value in inferential statistics (a very different number).

T-scores are very similar to *z*-scores - the provide scores for each person relative to a frame of reference. With *z*-scores we use 0 to indicate the mean of the frame of reference and 1.0 to indicate the standard deviation of the frame of reference. With T-scores we use 50 to indicate the mean of the frame of reference and 10 to indicate the standard deviation of the frame of reference.

When T-scores are greater than 50 this indicates that a person is above the mean of the frame of reference; likewise, when a T-scores is less than 50 this indicates that a person is below the mean of the frame of reference. Every difference of 10 units from 50 represents a standard deviation. Thus, a person with a T-score of 60 is one standard deviation above the mean of the frame of reference.

In we example our data we find that John has a height of 190 cm. We use the heights of the people in our data set as a frame of reference. To create a T-score for John we first need to convert his height in cm to a *z*-score. Following this, we convert his *z*-score to a T-score. Fortunately, we've already calculated John's height in *z*-score form for this frame of reference as 2.084084. We convert that number (calculation below) to a T-score of 
70.84084. Because this T-score if greater than 50 we know John is taller than the average person in the frame of reference (i.e, the people in our data set). Likewise, the magnitude of the T-score is roughly 20 higher (i.e., 2* 10 higher) than 50 we know John is about 2 standard deviations taller than the mean for the frame of reference.

#### Hand calculation

Let's walk through converting John's height as a *z*-score to a T-score. The score used our entire data set as the frame of reference - so that will be the frame of reference for the T-score as well.

The generic formula for converting *z*-scores to T-scores is below. You can see that we simply multiply a *z*-score by 10 and add 50 to get a T-score for that same frame of reference.

$$
\begin{aligned}
T_i = z_i \times 10 + 50\\
\end{aligned}
$$


Here is the calculation for John:

$$
\begin{aligned}
T_i &= z_i \times 10 + 50\\
&= \text{(John's height as a z-score)} \times 10 + 50\\
&= 2.084084 * 10 + 50\\
&= 70.84084\\
\end{aligned}
$$


As noted previously: Because this T-score if greater than 50 we know John is taller than the average person in the frame of reference (i.e, the people in our data set). Likewise, the magnitude of the T-score is roughly 20 higher (i.e., 2* 10 higher) than 50 we know John is about 2 standard deviations taller than the mean for the frame of reference.

#### R calculation

We can use this same approach in R to convert all of the *z*-scores to T-scores. Notice how the mutate() command below is just the R version of the above formula for converting *z*-scores to T-scores.

```{r}

height_data <- height_data %>%
  mutate(T_data =  z_data * 10 + 50 )
```

After running the above command, you can see everyone's height as a T-score with the code below. We omit the sex column from the output (using the select() command) so there are not too many columns on your screen.

```{r}
height_data %>%
  select(-part_id, -sex) %>%
  arrange(cm_height) %>%
  as.data.frame()
```


When you examined the output above did you notice correspondence between *z*-scores and T-scores. Whenever a *z*-score was less than 0 the corresponding T-score for that person was less than 50. Both of these values indicate a person had a height lower than the mean for the reference group (the entire data set).


#### Summary

We can obtain the mean for the cm, inches, *z*-score, and T-score columns with the command below:

```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x)
)

height_data %>%
    summarise(across(.cols = where(is.numeric),
                     .fns = desired_descriptives,
                     na.rm = TRUE)) %>%
  as.data.frame() %>% t()
```

We can see this information presented in table form below (decimals adjusted). You can see that T-scores are simply a way of representing heights with a different type of unit. By converting heights to T-scores we have not changed anyone's actual height. Nor have we changed the relative heights of any two individuals. We have only changed the units used to express those heights.

A special case: Also notice that when we use the data set itself as the frame of reference something interesting happens with T-scores. Specifically, the T-score column has a mean of 50 and a standard deviation of 10. This won't always be the case. If we use a frame of reference other than our data set, the mean and standard deviation of T-scores in our data set will not necessarily be equal to 50 and 10, respectively.


```{r, echo = FALSE}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x),
  N = ~sum(!is.na(.x))
)

row_sum <- height_data %>% 
  summarise(across(.cols = where(is.numeric),
                   .fns =  desired_descriptives,
                   .names = "{col}___{fn}"))

long_summary <- row_sum %>%
  pivot_longer(cols = everything(),
               names_to = c("unit", "stat"),
               names_sep = c("___"),
               values_to = "value")

summary_table <- long_summary %>% 
  pivot_wider(names_from = stat,
              values_from = value)

# round to 3 decimals
summary_table_rounded <- summary_table %>%
  mutate(across(.cols = where(is.numeric),
                .fns= round,
                digits = 3)) %>%
  as.data.frame()

kableExtra::kable(summary_table_rounded)
```


## Comparing scores

We sort the scores by height with the command below:

```{r}
height_data %>%
  select(-part_id, -sex) %>%
  arrange(cm_height) %>%
  as.data.frame()
```

Notice in the output above how all the people with heights below the mean of 173.3 cm have *z*-scores less than 0 and T-scores less than 50.


## Frame of references


### All participants


In the above excercises we used the entire data set as our frame of reference. That is, the z_data column was calculated using the mean and standard deviation for all participants. These values are presented below:


$$
\begin{aligned}
\overline{X} &= 173.3 \\
S_X &= 8.013114 \\
\end{aligned}
$$

These mean and standard deviation values were used to calculate John's *z*-score (and everyone else's *z*-scores too):

$$
\begin{aligned}
z_i &= \frac{X_i - \overline{X}}{S_X}\\
&= \frac{\text{(John's height in cm)} - \overline{X}}{S_X}\\
&= \frac{190 - 173.3}{8.013114}\\
&= \frac{16.7}{8.013114}\\
&= 2.084084\\
\end{aligned}
$$


### Male reference

Let's examine only the male participants for the next part of the exercise. We want to determine how tall each male is relative to other males. Instead of using entire data set as the frame of reference when we calculate z-scores we will use only males as the frame of reference.


We can obtain a data set with only the males by using the command below:

```{r}
male_height_data <- height_data %>%
  filter(sex == "male") 
```

You can confirm we have only males in the data with this command:

```{r}
male_height_data %>%
  select(-part_id, -sex, -T_data) %>%
  arrange(cm_height) %>%
  as.data.frame()
```

We see the mean and standard deviation for males is:


```{r}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x)
)

male_height_data %>%
    summarise(across(.cols = starts_with("cm_"),
                     .fns = desired_descriptives,
                     na.rm = TRUE)) %>%
  as.data.frame() %>% t()
```


#### Hand calculation

Thus, for males only:

$$
\begin{aligned}
\overline{X_{males}} &= 178.7 \\
S_{males} &= 6.558201 \\
\end{aligned}
$$



Previously, when we used the whole data set as a frame of reference we found that John's *z*-score was 2.084084. But now we want to calculate a *z*-score for John using only the males as a frame of reference. Therefore, we calculate his *z*-score using the mean and standard deviation for only males; as illustrated below:


$$
\begin{aligned}
z_i &= \frac{X_i - \overline{X_{males}}}{S_{males}}\\
&= \frac{\text{(John's height in cm)} - \overline{X_{males}}}{S_{males}}\\
&= \frac{190 - 178.7}{6.558201}\\
&= \frac{11.3}{6.558201}\\
&= 1.723033\\
\end{aligned}
$$



#### R calculation


```{r}

male_height_data <- male_height_data %>%
  mutate(z_data_males = (cm_height - 178.7)/ 6.5582  )
```


```{r}
male_height_data %>%
  select(-part_id, -sex, -T_data, -inch_height) %>%
  arrange(cm_height) %>%
  as.data.frame()
```



```{r, echo = FALSE}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x),
  N = ~sum(!is.na(.x))
)

row_sum <- male_height_data %>% 
  select(-part_id, -sex, -T_data, -inch_height) %>%
  summarise(across(.cols = where(is.numeric),
                   .fns =  desired_descriptives,
                   .names = "{col}___{fn}"))

long_summary <- row_sum %>%
  pivot_longer(cols = everything(),
               names_to = c("unit", "stat"),
               names_sep = c("___"),
               values_to = "value")

summary_table <- long_summary %>% 
  pivot_wider(names_from = stat,
              values_from = value)

# round to 3 decimals
summary_table_rounded <- summary_table %>%
  mutate(across(.cols = where(is.numeric),
                .fns= round,
                digits = 3)) %>%
  as.data.frame()

kableExtra::kable(summary_table_rounded)
```


### Canadian reference


$$
\begin{aligned}
\overline{X_{males_canada}} &= 176.1 \\
S_{males_canada} &= 7.20 \\
\end{aligned}
$$


#### Hand calculation

$$
\begin{aligned}
z_i &= \frac{X_i - \overline{X_{males_canada}}}{S_{males_canada}}\\
&= \frac{\text{(John's height in cm)} - \overline{X_{males_canada}}}{S_{males_canada}}\\
&= \frac{190 - 176.1}{7.20}\\
&= \frac{13.9}{7.20}\\
&= 1.930556\\
\end{aligned}
$$


#### R calculation


```{r}

male_height_data <- male_height_data %>%
  mutate(z_canada_males = (cm_height - 176.1)/ 7.20  )
```

```{r}
male_height_data %>%
  select(-part_id, -sex, -T_data, -inch_height) %>%
  filter(name == "John") %>%
  as.data.frame()
```


```{r}
male_height_data %>%
  select(-part_id, -sex, -T_data, -inch_height) %>%
  arrange(cm_height) %>%
  as.data.frame()
```




```{r, echo = FALSE}
desired_descriptives <- list(
  mean = ~mean(.x, na.rm = TRUE),
  sd_pop = ~sd_pop(.x),
  N = ~sum(!is.na(.x))
)

row_sum <- male_height_data %>% 
  select(-part_id, -sex, -T_data, -inch_height) %>%
  summarise(across(.cols = where(is.numeric),
                   .fns =  desired_descriptives,
                   .names = "{col}___{fn}"))

long_summary <- row_sum %>%
  pivot_longer(cols = everything(),
               names_to = c("unit", "stat"),
               names_sep = c("___"),
               values_to = "value")

summary_table <- long_summary %>% 
  pivot_wider(names_from = stat,
              values_from = value)

# round to 3 decimals
summary_table_rounded <- summary_table %>%
  mutate(across(.cols = where(is.numeric),
                .fns= round,
                digits = 3)) %>%
  as.data.frame()

kableExtra::kable(summary_table_rounded)
```

